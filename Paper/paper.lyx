#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
\usepackage{algorithm,algpseudocode}
\usepackage{prettyref}
\newrefformat{tab}{Table\,\ref{#1}}
\newrefformat{fig}{Figure\,\ref{#1}}
\newrefformat{eq}{Eq.\,\textup{(\ref{#1})}}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\listings_params "language={C++},keywordstyle={\color{blue}},commentstyle={\color{green}\itshape},emphstyle={\color{red}},breaklines=true,basicstyle={\ttfamily},stringstyle={\color{green}},morekeywords={cilk_for,cilk_spawn,cilk_sync,size_t},tabsize=2,identifierstyle={\color{cyan}}"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Parallel Algorithms for Evaluating Matrix Polynomials
\end_layout

\begin_layout Author
Sivan Toledo, Amit Waisel
\end_layout

\begin_layout Abstract
We designed, implemented and evaluated a parallel algorithm for calculating
 matrix polynomials.
 The algorithms has some variations, which we will go over in this article.
 The results, compared to other implementations, are promising.
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
We describe parallel algorithm for evaluating matrix polynomials.
 Given a real or complex matrix 
\begin_inset Formula $A$
\end_inset

 and a polynomial 
\begin_inset Formula $q$
\end_inset

 with coefficients 
\begin_inset Formula $c_{0},c_{1},...,c_{d}$
\end_inset

, we wish to compute the matrix
\begin_inset Formula 
\begin{equation}
q(A)=\sum_{k=0}^{d}c_{k}\cdot A^{k}=c_{o}\cdot I+c_{1}\cdot A+c_{2}\cdot A^{2}+...+c_{d}\cdot A^{d}\;.\label{eq:polynomial-def-1}
\end{equation}

\end_inset

The expression above suggests a way to evaluate 
\begin_inset Formula $q(A)$
\end_inset

, but it turns out that in most cases, there are more efficient ways to
 compute it.
 Our main aim in the research that we describe here was to find parallel
 variants of the building blocks of the most efficient algorithms to evaluate
 matrix polynomials.
 Some of our contributions are specific to this problem, but some address
 building blocks that are used in the evaluation of other functions of matrices.
\end_layout

\begin_layout Standard
Naive algorithms for evaluating 
\begin_inset Formula $q(A)$
\end_inset

 perform about 
\begin_inset Formula $d-1$
\end_inset

 matrix multiplications; the total work (arithmetic and other basic operations)
 is 
\begin_inset Formula $\Theta(n^{\omega}d),$
\end_inset

where 
\begin_inset Formula $\omega$
\end_inset

 is the exponent of matrix multiplication, 
\begin_inset Formula $\omega=3$
\end_inset

 for conventional matrix multiplication, 
\begin_inset Formula $\omega\approx2.7$
\end_inset

 for Strassen's matrix multiplication
\begin_inset space ~
\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
CITE strassen and a recent survey
\end_layout

\end_inset

.
 More efficient algorithms are based on two key insignts.
 
\end_layout

\begin_layout Standard
One is an algorithm by Patterson and Stockmeyer
\begin_inset space ~
\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
CITE
\end_layout

\end_inset

 that rearranges Equation
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:polynomial-def-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

) in the form of a polynomial in 
\begin_inset Formula $A^{p}$
\end_inset

 for some 
\begin_inset Formula $p<d$
\end_inset

 with coefficients that are themselves polynomials in 
\begin_inset Formula $A$
\end_inset

 with degree at most 
\begin_inset Formula $p-1$
\end_inset

.
 A good choise of 
\begin_inset Formula $p$
\end_inset

 leads to an algorithm with arithmetic complexity 
\begin_inset Formula $\Theta(n^{\omega}\sqrt{d})$
\end_inset

.
\end_layout

\begin_layout Standard
The other is an algorithm by Parlett 
\begin_inset Note Note
status open

\begin_layout Plain Layout
CITE
\end_layout

\end_inset

, which is applicable to any function of 
\begin_inset Formula $A$
\end_inset

, but which may be unstable.
 Parlett's algorithm reduces 
\begin_inset Formula $A$
\end_inset

 to its Schur form 
\begin_inset Formula $A=QTQ^{*}$
\end_inset

, computes the function (here the polynomial 
\begin_inset Formula $q$
\end_inset

) of the diagonal elements of 
\begin_inset Formula $T$
\end_inset

, then solves recurrence equations for the off-diagonal elements of 
\begin_inset Formula $q(T)$
\end_inset

, and finally multiplies back 
\begin_inset Formula $q(A)=Qq(T)Q^{*}.$
\end_inset

 When this method works, its computational complexity is 
\begin_inset Formula $\Theta(n^{3})$
\end_inset

, but it is numerically unstable when 
\begin_inset Formula $A$
\end_inset

 has repeated or clustered eigenvalues.
 A variant by Davies and Higham
\begin_inset space ~
\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
CITE
\end_layout

\end_inset

 fixes the instability by clustering the eigenvalues of 
\begin_inset Formula $A$
\end_inset

 into well-separated clusters and by applying a block form of Parlett's
 recurrences.
 The method of Davies and Higham requires a subroutine to evaluate 
\begin_inset Formula $q$
\end_inset

 on diagonal blocks of 
\begin_inset Formula $T$
\end_inset

; we can use Patterson Stockmeyer's method to do that efficiently.
 The evaluation of off-diagonal blocks in the Davies-Higham method requires
 solving Sylvester equations, so this is another building block that we
 parallelized.
\end_layout

\begin_layout Standard
The running time of numerical algorithms on modern hardware is influenced
 by many factors.
 The number of arithmetic operations is one of them, but it is not the only
 one and often not the most important one.
 Data-access patterns also have a significant influence on running times,
 as is the number of computational units that can be effectively used in
 parallel.
 In this paper we focus on the last issue, parallelism.
 We build upon results in an earlier paper that focused on locality and
 data-access patterns
\begin_inset space ~
\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
CITE
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Our contributions are as follows:
\end_layout

\begin_layout Enumerate
We developed high-performance implementations of all the building blocks
 mentioned above, including variants that use the real Schur form to compute
 polynomials of real matrices with complex eigenvalues.
 
\end_layout

\begin_layout Enumerate
We parallelized the Patterson-Stockmeyer algorithm.
\end_layout

\begin_layout Enumerate
We parallelized the Parlett-Davies-Higham block recurrence.
\end_layout

\begin_layout Enumerate
We parallelized a recursive Sylvester solver.
\end_layout

\begin_layout Enumerate
We explored optimizations in the Schur-reordering algorithm, which is used
 to prepare the Schur form for the Davies-Higham method.
\end_layout

\begin_layout Enumerate
We conducted extensive experiments to evaluate the effectiveness of our
 algorithms and to assess the effectiveness of different variants.
 An imporant aspect of these assessments is the question of whether to paralleli
ze high level algorithms (e.g., the Davies-Higham block recurrence) or to
 rely on parallelization of their subroutines (e.g., the Sylvester solver).
\end_layout

\begin_layout Standard
The rest of this paper is organized as follows.
\end_layout

\begin_layout Standard
—
\end_layout

\begin_layout Standard
This paper introduces some parallel and efficient algorithms for fast matrix
 polynomial calculations.
 We describe numerous approaches for calculating the polynomials, and analyze
 the implications of different properties of the input matrices.
 Our algorithm uses existing algorithms as building blocks, as discussed
 below.
 Our contributions are:
\end_layout

\begin_layout Enumerate
Adapt existing algorithms for handling the real-form of the polynomial instead
 of dealing with complex numbers
\end_layout

\begin_layout Enumerate
Develop new algorithms for reducing overall calculation costs.
 The existing algorithms reduce the matrix to real-schur-form, and cluster
 the eigenvalues on its diagonal for better concurrency operation.
 We will analyze the implications of sorting the eigenvalues and show a
 way to minimize the swaps.
\end_layout

\begin_layout Enumerate
Analyze and evaluate different aspects of the algorithms used, such as clusterin
g tolerance, solving Sylvester equations in parallel and the order in which
 the sub-calculations are executed by.
\end_layout

\begin_layout Standard
Many methods for computing matrix functions require the evaluation of a
 matrix polynomial.
 We denote the 
\begin_inset Formula $n\times n$
\end_inset

 real or complex input matrix by 
\begin_inset Formula $A$
\end_inset

, the polynomial by 
\begin_inset Formula $q$
\end_inset

, and we assume that it is given by its coefficient 
\begin_inset Formula $c_{0},c_{1},...,c_{d}$
\end_inset

.
 That is, we wish to compute the matrix:
\begin_inset Formula 
\begin{equation}
q(A)=\sum_{k=0}^{m}c_{k}\cdot A^{k}=c_{o}\cdot I+c_{1}\cdot A+c_{2}\cdot A^{2}+...+c_{d}\cdot A^{d}\label{eq:polynomial-def}
\end{equation}

\end_inset

where 
\begin_inset Formula $A\in\mathbb{C}^{n\times n}$
\end_inset

 (or 
\begin_inset Formula $A\in\mathbb{R}^{n\times n}$
\end_inset

).
 We assume that the polynomial is dense, in the sense that either no 
\begin_inset Formula $c_{i}$
\end_inset

-s are zero or too few to be worth exploiting.
\end_layout

\begin_layout Standard
Using Matlab as a baseline, our algorithms shows very promising results,
 especially for high-rank polynomials on high-rank matrices.
\end_layout

\begin_layout Section
Existing Algorithms
\end_layout

\begin_layout Standard
This section presents existing algorithmic building blocks for evaluating
 polynomials of a matrix.
\end_layout

\begin_layout Subsection
Matrix Multiplication Methods
\end_layout

\begin_layout Standard
Matrix multiplication is a fundamental part in all of the algorithm variations
 described below.
 The classic and straight-forward matrix multiplication operation takes
 about 
\begin_inset Formula $2n^{3}$
\end_inset

 floating-point operations.
 An optimized variation of calculating matrix-matrix product is implemented
 in 
\shape italic
?GEMM
\shape default
 (for general matrices) inside BLAS library.
 More efficient matrix-multiplication algorithms exist, like Strassen or
 Strassen-Wingograd methods.
 They execute asymptotically smaller amount of floating-point operations
 (exponent of about 
\begin_inset Formula $2^{\lg7}$
\end_inset

) while their constant factors are usually larger than those in classical
 methods.
 Their biggest disadvantage is their little numeric stability, especially
 in small matrix dimensions.
\end_layout

\begin_layout Standard
The algorithms introduced below mainly calculate matrix-matrix product of
 small matrices, while paralleling the calculation of many products.
 Therefore, Strassen-like methods will not be effective, and even harm the
 numeric stability of our implementation.
\end_layout

\begin_layout Subsection
Polynomial Evaluation by Patterson-Stockmeyer
\end_layout

\begin_layout Standard
Whereas Horner’s method (nested multiplication, which will be introduced
 below) is almost always used in the scalar case, for matrix polynomials
 there are four competing methods.
\end_layout

\begin_layout Subsubsection
Explicit powers
\end_layout

\begin_layout Standard
The first method for evaluating the polynomial is to calculate its explicit
 powers.
 This naive polynomial evaluation simply calculates all powers of 
\begin_inset Formula $A$
\end_inset

 from 
\begin_inset Formula $A^{2}$
\end_inset

 to 
\begin_inset Formula $A^{d}$
\end_inset

 and accumulates the polynomial for each power, starting from 
\begin_inset Formula $Q=c_{0}\cdot I$
\end_inset

.
 The powers are calculated by multiplying 
\begin_inset Formula $A_{k-1}$
\end_inset

 by 
\begin_inset Formula $A$
\end_inset

 for every 
\begin_inset Formula $k=1...d$
\end_inset

, and adding them to the accumulated matrix 
\begin_inset Formula $Q=Q+c_{k}A^{k}$
\end_inset

.
 Therefore, 
\begin_inset Formula $d-1$
\end_inset

 matrix multiplication calculations are performed, as well as scale-and-add
 operations.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Evaluate polynomial via explicit powers
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
This algorithm evaluates the polynomial 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:polynomial-def"

\end_inset

 by explicitly forming matrix powers.
\end_layout

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:explicit_powers"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}[1]
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset


\begin_inset Formula $P=A$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset


\begin_inset Formula $Q=c_{0}I+c_{1}A$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
For{$k=2:d$}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset


\begin_inset Formula $P=P\cdot A$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset


\begin_inset Formula $Q=Q+c_{k}P$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\end_inset

 
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Horner's Rule
\end_layout

\begin_layout Standard
The second approach which was mentioned above, denoted as Horner’s rule,
 is to accumulate the polynomial, meaning we start from 
\begin_inset Formula $Q=c_{d}\cdot A+c_{d-1}\cdot I$
\end_inset

 and multiply 
\begin_inset Formula $Q$
\end_inset

 by 
\begin_inset Formula $A$
\end_inset

 in each step, while adding a scaled identity matrix: 
\begin_inset Formula $Q=Q\cdot A+c_{k}I$
\end_inset

.
 Horner’s rule also calculates 
\begin_inset Formula $d-1$
\end_inset

 matrix products, while only adding a constant to the diagonal of every
 
\begin_inset Formula $Q$
\end_inset

 along the way (as 
\begin_inset Formula $c_{k}I$
\end_inset

 contains values only on the diagonal), which is cheaper than scale-and-add
 operations.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Horner’s method
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
This algorithm evaluates the polynomial 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:polynomial-def"

\end_inset

 by Horner’s method.
\end_layout

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:horner_rule"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}[1]
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset


\begin_inset Formula $Q=c_{d}X+c_{d-1}I$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset


\begin_inset Formula $Q=c_{0}I+c_{1}A$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
For{$k=d-2:-1:0$}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset


\begin_inset Formula $Q=A\cdot Q+c_{k}I$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\end_inset

 
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Horner’s method is not suitable when 
\begin_inset Formula $d$
\end_inset

 is not known at the start of the evaluation, as is often the case when
 a truncated power series is to be summed.
 In this case 
\begin_inset Formula $q(A)$
\end_inset

 can be evaluated by explicitly forming each power of 
\begin_inset Formula $A$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Factored form
\end_layout

\begin_layout Standard
Another method for calculating the polynomial, factorizes the polynomial
 
\begin_inset Formula $q(A)=c_{d}(A-\zeta_{1})\cdot...\cdot(A-\zeta_{d})$
\end_inset

 (where 
\begin_inset Formula $\zeta_{1},...,\zeta_{d}$
\end_inset

 are the polynomial roots) and then evaluates this factorized form for the
 input matrix 
\begin_inset Formula $A$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Evaluate polynomial in factored form
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
This algorithm evaluates the polynomial 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:polynomial-def"

\end_inset

 given the roots 
\begin_inset Formula $\zeta_{1},...,\zeta_{d}$
\end_inset

 of 
\begin_inset Formula $q(A)$
\end_inset

.
\end_layout

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:factored_form"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}[1]
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset


\begin_inset Formula $Q=A\text{−}\zeta_{d}\cdot I$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
For{$k=d-1:-1:1$}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset


\begin_inset Formula $Q=Q\cdot(A-\zeta_{k}\cdot I)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\end_inset

 
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\end_inset

One drawback to Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:factored_form"

\end_inset

 is that some of the roots 
\begin_inset Formula $\zeta_{j}$
\end_inset

 may be complex and so complex arithmetic may be required even when the
 polynomial and 
\begin_inset Formula $A$
\end_inset

 are both real.
\end_layout

\begin_layout Subsubsection
Patterson-Stockmeyer
\end_layout

\begin_layout Standard
The fourth and least obvious method is that of Patterson and Stockmeyer.
 They developed an algorithm for evaluating 
\begin_inset Formula $q(A)$
\end_inset

 using only about 
\begin_inset Formula $2\sqrt{d}$
\end_inset

 matrix-matrix multiplications, as opposed to 
\begin_inset Formula $d-1$
\end_inset

 operations in the naive methods described above.
 Patterson and Stockmeyer algorithm splits the 
\begin_inset Formula $d$
\end_inset

 monomials (
\begin_inset Formula $c_{i}A^{i}$
\end_inset

) in 
\begin_inset Formula $q(A)$
\end_inset

 into 
\begin_inset Formula $s$
\end_inset

 subsets of (approximately) 
\begin_inset Formula $p$
\end_inset

 monomials each.
 Each subset is a summary of at-most 
\begin_inset Formula $p$
\end_inset

 monomials, so it can be represented as a polynomial of degree 
\begin_inset Formula $p-1$
\end_inset

 at most for 
\begin_inset Formula $A$
\end_inset

, times some power of 
\begin_inset Formula $A^{p}$
\end_inset

.
\end_layout

\begin_layout Standard
For clarity, let’s assume that 
\begin_inset Formula $d+1$
\end_inset

 divides to integers 
\begin_inset Formula $p,s$
\end_inset

 such that 
\begin_inset Formula $d+1=ps$
\end_inset

.
 We can define 
\begin_inset Formula $q(A)=c_{0}I+c_{1}A+c_{2}A^{2}+...+c_{d}A^{d}$
\end_inset

 as a summary of 
\begin_inset Formula $s$
\end_inset

 polynomials of degree 
\begin_inset Formula $p-1$
\end_inset

 each: 
\begin_inset Formula 
\begin{multline}
q(A)=(c_{0}I+c_{1}A+\cdots+c_{p-1}A^{p-1})(A^{p})^{0}+\\
(c_{p}I+c_{p+1}A+\cdots+c_{2p-1}A^{p-1})(A^{p})^{1}+\\
(c_{2p}I+c_{2p+1}A+\cdots+c_{3p-1}A^{p-1})(A^{p})^{2}+\\
\cdots+\\
+(c_{(s-1)p}I+c_{(s-1)p+1}A+\cdots+c_{sp-1}A^{p-1})(A^{p})^{s-1}\label{eq:ps-polynomial}
\end{multline}

\end_inset

In fact, 
\begin_inset Formula $q(A)$
\end_inset

 is now represented as a degree-
\begin_inset Formula $(s-1)$
\end_inset

 polynomial of 
\begin_inset Formula $A^{p}$
\end_inset

, with coefficients that are polynomials of degree 
\begin_inset Formula $p-1$
\end_inset

 each.
 This representation assumes that 
\begin_inset Formula $q$
\end_inset

 is dense, and that 
\begin_inset Formula $d+1$
\end_inset

 can be divided to two integers without a remainder.
 In the case where 
\begin_inset Formula $q(A)$
\end_inset

 is sparse, some monomials will be missing from the sub-polynomials (of
 degree 
\begin_inset Formula $p-1$
\end_inset

) - so their coefficients 
\begin_inset Formula $c_{i}$
\end_inset

-s can be treated as 
\begin_inset Formula $0$
\end_inset

.
 In addition, when 
\begin_inset Formula $d-1$
\end_inset

 cannot be factorized to integers, the last sub-polynomial will be of smaller
 degree and will have less than 
\begin_inset Formula $p$
\end_inset

 monomials.
\end_layout

\begin_layout Standard
Implementing Patterson-Stockmeyer algorithms requires calculating 
\begin_inset Formula $A^{2},...,A^{p}$
\end_inset

 in advance (to be used in all sub-polynomials) and calculates each sub-polynomi
al using any of the naive approaches described above.
 Then, calculating the polynomial 
\begin_inset Formula $q(A)$
\end_inset

 of 
\begin_inset Formula $A^{p}$
\end_inset

 with 
\begin_inset Formula $s$
\end_inset

 coefficients (all the sub-polynomials) can be applied using Horner’s rule.
\end_layout

\begin_layout Standard
In the full-and-dense case where 
\begin_inset Formula $d+1=ps$
\end_inset

, the total number of matrix multiplications that the method performs is
 
\begin_inset Formula $(p-1)(s-1)=p+s-2$
\end_inset

.
 Note that any matrix multiplication algorithm can be used here, and that
 if 
\begin_inset Formula $A$
\end_inset

 is triangular, so are all the intermediate matrices that the algorithm
 computes.
\end_layout

\begin_layout Standard
In addition, the number of matrix scale-and-add operations for each sub-polynomi
als is 
\begin_inset Formula $p-1$
\end_inset

, which totals to 
\begin_inset Formula $s(p-1)$
\end_inset

 across all sub-polynomials together.
\end_layout

\begin_layout Standard
To avoid re-calculation of matrix powers or coefficients, the number of
 matrices that have to be stored is 
\begin_inset Formula $(p-1)+1+1+1=p+2$
\end_inset

.
 
\begin_inset Formula $p-1$
\end_inset

 stands for 
\begin_inset Formula $A^{2},...,A^{p}$
\end_inset

 that are calculated and cached to be used for all sub-polynomials, and
 the 
\begin_inset Formula $3$
\end_inset

 additional matrices are the accumulated 
\begin_inset Formula $(A^{p})^{k}$
\end_inset

, the matrix used for calculating each sub-polynomial, and the one used
 to accumulate all sub-polynomials (multiplied by 
\begin_inset Formula $(A^{p})^{k}$
\end_inset

) calculated so far.
\end_layout

\begin_layout Standard
The calculation cost is minimized by minimizing 
\begin_inset Formula $p+s$
\end_inset

, which happens near 
\begin_inset Formula $p\approx s\approx\sqrt{d}$
\end_inset

.
\end_layout

\begin_layout Subsection
Reduction to Triangular Matrices and Schur Decomposition
\end_layout

\begin_layout Standard
Using well-conditioned similarity transformations is a key requirement in
 order to maintain numerical stability of the calculation.
 In particular, restricting to unitary transformations tightly keeps the
 numerical stability.
 In general, the best method to transform a matrix to diagonal form via
 unitary similarities is the Schur triangular form.
 The Schur decomposition factors 
\begin_inset Formula $A\in\mathbb{C}^{n\times n}$
\end_inset

 as 
\begin_inset Formula $A=QTQ^{*}$
\end_inset

, where 
\begin_inset Formula $Q\in\mathbb{C}^{n\times n}$
\end_inset

 is unitary and 
\begin_inset Formula $T\in\mathbb{C}^{n\times n}$
\end_inset

 is upper triangular.
 The eigenvalues of 
\begin_inset Formula $A$
\end_inset

 appear on the diagonal of 
\begin_inset Formula $T$
\end_inset

.
\end_layout

\begin_layout Standard
When 
\begin_inset Formula $A$
\end_inset

 is real, 
\begin_inset Formula $T$
\end_inset

 may be complex.
 Calculating a real-schur-form yields a real upper quasi-triangular matrix
 
\begin_inset Formula $T$
\end_inset

, with 1-by-1 and 2-by-2 blocks on its diagonal.
 2-by-2 blocks will be standardized in the form 
\begin_inset Formula $\begin{bmatrix}a & b\\
c & d
\end{bmatrix}$
\end_inset

 where 
\begin_inset Formula $b\cdot c<0$
\end_inset

.
 The eigenvalues of such a block are 
\begin_inset Formula $a\pm i\sqrt{bc}$
\end_inset

.
\end_layout

\begin_layout Standard
The Schur decomposition can be computed with perfect backward stability
 by the QR algorithm, and hence it is a standard tool in numerical linear
 algebra.
 Since 
\begin_inset Formula $f(A)=Qf(T)Q^{*}$
\end_inset

, this decomposition reduces the 
\begin_inset Formula $f(A)$
\end_inset

 problem to that of computing 
\begin_inset Formula $f(T)$
\end_inset

 for a triangular matrix.
 Therefore, building a solution for calculating the polynomial of triangular
 matrices will also cover general matrices.
\end_layout

\begin_layout Subsection
Parlett Recurrence
\end_layout

\begin_layout Standard
The Parlett Recurrence method (introduced by Parlett-David-Higham) can be
 applied once the matrix polynomial calculation is reduced to (quasi) triangular
 matrix, .
\end_layout

\begin_layout Standard
This method requires the matrix function (polynomial calculation in particular)
 to be calculated directly for smaller blocks on the diagonal, and then
 applies the following algorithm to calculate the elements outside those
 blocks.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Parlett Recurrence
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Given an upper triangular 
\begin_inset Formula $T\in\mathbb{C}^{n\times n}$
\end_inset

 with distinct diagonal elements and a function f defined on the spectrum
 of 
\begin_inset Formula $T$
\end_inset

, this algorithm computes 
\begin_inset Formula $F=f(T)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}[1]
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset

 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $f_{ii}=f(t_{ii})$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Comment
\end_layout

\end_inset

 Calculate function 
\begin_inset Formula $f$
\end_inset

 for all diagonal elements
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
For{$j=2:n$}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
For{$i=j-1:-1:1$}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset


\begin_inset Formula 
\begin{equation}
f_{ij}=t_{ij}\cdot\frac{f_{ii}-f_{jj}}{t_{ii}-t_{jj}}+\nicefrac{\sum_{k=i+1}^{j-1}(f_{ik}t_{kj}-t_{ik}f_{kj})}{t_{ii}-t_{jj}}\label{eq:parlett_fij}
\end{equation}

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\end_inset

 
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Parlett’s recurrence fails to perform the calculation when 
\begin_inset Formula $t_{ii}=t_{jj}$
\end_inset

 for some 
\begin_inset Formula $i\neq j$
\end_inset

.
 As the diagonal elements are 
\begin_inset Formula $T$
\end_inset

’s eigenvalues, this condition is valid when 
\begin_inset Formula $T$
\end_inset

 has repeated eigenvalues.
 In this situation 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:parlett_fij"

\end_inset

 provides no information about 
\begin_inset Formula $f_{ij}$
\end_inset

.
 To handle this situation, a blocked version of Parlett recurrence can be
 applied.
\end_layout

\begin_layout Subsubsection
Blocked Parlett Recurrence
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $T=(Ti_{j})$
\end_inset

 be block upper triangular with square diagonal blocks, possibly of different
 sizes.
 Then 
\begin_inset Formula $F=(Fij)$
\end_inset

 has the same block structure.
 Equating 
\begin_inset Formula $(i,j)$
\end_inset

 blocks in 
\begin_inset Formula $TF=FT$
\end_inset

 leads to 
\begin_inset Formula 
\begin{equation}
T_{ii}F_{ij}\text{−}F_{ij}T_{jj}=F_{ii}T_{ij}\text{−}T_{ij}F_{jj}+\sum_{k=i+1}^{j\text{−}1}(F_{ik}T_{kj}\text{−}T_{ik}F_{kj}),\:i<j\label{eq:parlett_block_sylvester}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Block Parlett Recurrence
\begin_inset CommandInset label
LatexCommand label
name "alg:Block-Parlett-Recurrence"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Given a triangular matrix 
\begin_inset Formula $T=(Tij)\in\mathbb{C}^{n\times n}$
\end_inset

 partitioned in block form, with no two diagonal blocks having an eigenvalue
 in common, and a function 
\begin_inset Formula $f$
\end_inset

 defined on the spectrum of 
\begin_inset Formula $T$
\end_inset

, this algorithm computes 
\begin_inset Formula $F=f(T)$
\end_inset

 using the block form of Parlett’s recurrence.
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}[1]
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset

 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $F_{ii}=f(T_{ii})$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 - Calculate function 
\begin_inset Formula $f$
\end_inset

 for all diagonal blocks
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
For{$j=2:n$}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
For{$i=j-1:-1:1$}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset

 Solve the Sylvester equation 
\begin_inset Formula $T_{ii}F_{ij}\text{−}F_{ij}T_{jj}=F_{ii}T_{ij}\text{−}T_{ij}F_{jj}+\sum_{k=i+1}^{j\text{−}1}(F_{ik}T_{kj}\text{−}T_{ik}F_{kj})$
\end_inset

 for 
\begin_inset Formula $F_{ij}$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\end_inset

 
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\end_inset

This recurrence can be used to compute 
\begin_inset Formula $F$
\end_inset

 either a block superdiagonal
\begin_inset Foot
status open

\begin_layout Plain Layout
sub-diagonal of blocks
\end_layout

\end_inset

 at a time or a block column at a time, provided we can evaluate the diagonal
 blocks 
\begin_inset Formula $F_{ii}=f(T_{ii})$
\end_inset

 and solve the Sylvester equations 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:parlett_block_sylvester"

\end_inset

 for the 
\begin_inset Formula $F_{ij}$
\end_inset

.
 The Sylvester equation 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:parlett_block_sylvester"

\end_inset

 is non-singular if and only if 
\begin_inset Formula $T_{ii}$
\end_inset

 and 
\begin_inset Formula $T_{jj}$
\end_inset

 have no eigenvalue in common.
\end_layout

\begin_layout Standard
Therefore, in order to use this block recurrence, we need first to reorder
 the matrix 
\begin_inset Formula $T$
\end_inset

 so that no two diagonal blocks have an eigenvalue in common; Here, reordering
 means applying a unitary similarity transformation to permute the diagonal
 elements whilst preserving 
\begin_inset Quotes eld
\end_inset

triangularity
\begin_inset Quotes erd
\end_inset

.
 A reordering optimization is introduced below, as applying the unitary
 similarity transformation is computationally heavy.
 The two variations for calculating the recurrence are explored and analyzed
 below, as well as a parallel variant for solving Sylvester equations.
\end_layout

\begin_layout Subsection
Reorder matrix diagonal
\end_layout

\begin_layout Standard
To apply the blocked Parlett recurrence and maintain numeric stability,
 no two blocks of eigenvalues can contain identical (or close) values.
 Denote 
\begin_inset Formula $\tilde{T}$
\end_inset

 as the reordered and partitioned form of 
\begin_inset Formula $T$
\end_inset

.
 Let 
\begin_inset Formula $\delta>0$
\end_inset

 be a blocking parameter - aka a tolerance for checking whether two values
 or blocks are close.
 The blocks must be well separated and hold the following conditions:
\end_layout

\begin_layout Enumerate
The blocks are separated at least by tolerance : 
\begin_inset Formula 
\[
\min\left\{ |\lambda-\mu|:\lambda\in\Lambda(\tilde{T}_{ii}),\,\mu\in\Lambda(\tilde{T}_{jj}),\:i\neq j\right\} >δ
\]

\end_inset


\end_layout

\begin_layout Enumerate
All the values within a block are close to one another at most by tolerance
 
\begin_inset Formula $\delta$
\end_inset

: for every block 
\begin_inset Formula $\tilde{T}_{ii}$
\end_inset

 with dimension bigger than 1, for every 
\begin_inset Formula $\lambda\in\Lambda(\tilde{T}_{ii})$
\end_inset

 there is a 
\begin_inset Formula $\mu\in\Lambda(\tilde{T}_{ii})$
\end_inset

 such that 
\begin_inset Formula $\lambda\neq\mu,\,|\lambda-\mu|\le\delta$
\end_inset

.
 This implies that 
\begin_inset Formula $\max\{|\lambda-\mu|:\lambda,\mu\in\Lambda(\tilde{T}_{ii}),\:\lambda\neq\mu\}\le(m-1)\cdot\delta$
\end_inset

 for 
\begin_inset Formula $\tilde{T}_{ii}\in\mathbb{R}^{m\times m}\:(m>1)$
\end_inset

 and this bound is attained when, for example, 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\Lambda(\tilde{T}_{ii})=\{\delta,2\delta,\ldots,m\delta\}$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
.
\end_layout

\begin_layout Standard
To reorder the upper triangular Schur factor 
\begin_inset Formula $T$
\end_inset

 into blocks following the conditions described above, 
\begin_inset Formula $T$
\end_inset

 has to be transformed into a partitioned upper triangular matrix 
\begin_inset Formula $\tilde{T}=U^{*}\cdot T\cdot U=(\tilde{T}_{ij})$
\end_inset

, where 
\begin_inset Formula $U$
\end_inset

 is unitary.
 The transformation has to be applied using the following algorithm:
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Reorder Matrix Diagonal
\begin_inset CommandInset label
LatexCommand label
name "alg:Reorder-Matrix-Diagonal"

\end_inset


\end_layout

\end_inset

Given an upper tiangular Schur factor 
\begin_inset Formula $T$
\end_inset

 and its diagonal blocks, this algorithm reorders the diagonal blocks following
 the conditions described aboce, by transforming 
\begin_inset Formula $T$
\end_inset

 into a partitioned-upper-triangular matrix 
\begin_inset Formula $\tilde{T}=U^{*}\cdot T\cdot U=(\tilde{T}_{ij})$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}[1]
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset

 Cluster 
\begin_inset Formula $T$
\end_inset

’s eigenvalues to their designated blocks
\begin_inset CommandInset label
LatexCommand label
name "lst:line:reorder-cluster-blocks"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset

 Calculate the best permutation of the blocks, given the original location
 of each eigenvalue on the diagonal, to minimize the number of unitary similarit
y transformations applied to reorder the eigenvalues
\begin_inset CommandInset label
LatexCommand label
name "lst:line:reorder-calculate-permutation"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset

 Plan and apply the reordering according to the calculated permutation.
\begin_inset CommandInset label
LatexCommand label
name "lst:line:reorder-apply"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Cluster Eigenvalues to Designated Blocks
\end_layout

\begin_layout Standard
The first step of clustering 
\begin_inset Formula $T$
\end_inset

’s eigenvalues into their designated clusters, as described in algorithm
 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Reorder-Matrix-Diagonal"

\end_inset

 in step 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:line:reorder-cluster-blocks"

\end_inset

, is solved by algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Block-pattern"

\end_inset

 [ref to ch9] that provides a mapping from each eigenvalue 
\begin_inset Formula $\lambda_{i}$
\end_inset

 of 
\begin_inset Formula $T$
\end_inset

 to an integer 
\begin_inset Formula $q_{i}$
\end_inset

 such that the set 
\begin_inset Formula $S_{q_{i}}$
\end_inset

 contains 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\lambda_{i}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Block pattern
\begin_inset CommandInset label
LatexCommand label
name "alg:Block-pattern"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Given a triangular matrix 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $T_{ii}\in\mathbb{C}^{n\times n}$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 with eigenvalues 
\begin_inset Formula $\lambda_{i}\equiv t_{ii}$
\end_inset

 and a blocking parameter 
\begin_inset Formula $\delta>0$
\end_inset

, this algorithm produces a block pattern, defined by an integer vector
 
\begin_inset Formula $q$
\end_inset

, for the block Parlett recurrence; The eigenvalue 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\lambda_{i}$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 is assigned to the set 
\begin_inset Formula $S_{q_{i}}$
\end_inset

, and it satisfies the conditions that 
\begin_inset Formula $\min\{|\lambda_{i}-\lambda_{j}|:\lambda_{i}\in S_{p},\,\lambda_{j}\in S_{q},\:p\neq q\}>\delta$
\end_inset

 and, for each set 
\begin_inset Formula $S_{i}$
\end_inset

 with more than one element, every element of 
\begin_inset Formula $S_{i}$
\end_inset

 is within distance at most 
\begin_inset Formula $\delta$
\end_inset

 from some other element in the set.
 For each set 
\begin_inset Formula $S_{q}$
\end_inset

, all the eigenvalues in 
\begin_inset Formula $S_{q}$
\end_inset

 are intended to appear together in an upper triangular block 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\tilde{T}_{ii}$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 of 
\begin_inset Formula $\tilde{T}=U^{*}\cdot T\cdot U$
\end_inset

.
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}[1]
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset

 
\begin_inset Formula $p=1$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset

 Initialize 
\begin_inset Formula $S_{q}=\emptyset$
\end_inset

 for every 
\begin_inset Formula $q$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
For{$i=1:n$}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
If{$
\backslash
lambda_{i} 
\backslash
neq S_q$ for all $1 
\backslash
le q < p$}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset

 Assign 
\begin_inset Formula $\lambda_{i}$
\end_inset

 to 
\begin_inset Formula $S_{p}$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset

 
\begin_inset Formula $p=p+1$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndIf
\end_layout

\end_inset

 
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
For{$j=i+1:n$}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset

 Denote by 
\begin_inset Formula $S_{q_{i}}$
\end_inset

 the set that contains 
\begin_inset Formula $\lambda_{i}$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
If{$
\backslash
lambda_{i} 
\backslash
notin S_{q_{i}}$}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
If{$|
\backslash
lambda_{i} - 
\backslash
lambda_{j}| 
\backslash
le 
\backslash
delta$}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
If{$|lambda_{j} 
\backslash
notin S_{k}$ for all $1 
\backslash
le k < p$}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset

 Assign 
\begin_inset Formula $\lambda_{j}$
\end_inset

 to 
\begin_inset Formula $S_{q_{i}}$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Else
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset

 Move the elements of 
\begin_inset Formula $S_{\max(q_{i},q_{j})}$
\end_inset

 to 
\begin_inset Formula $S_{\min(q_{i},q_{k})}$
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Comment
\end_layout

\end_inset

 Can be done concurrently over all elements 
\begin_inset CommandInset label
LatexCommand label
name "lst:line:cluster-max-to-min-1"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset

 Reduce by 
\begin_inset Formula $1$
\end_inset

 the indices of sets 
\begin_inset Formula $S_{q}$
\end_inset

 for 
\begin_inset Formula $q>\max(q_{i},q_{j})$
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Comment
\end_layout

\end_inset

 Can be done concurrently over all 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $q>\max(q_{i},q_{j})$
\end_inset

 
\begin_inset CommandInset label
LatexCommand label
name "lst:line:cluster-max-to-min-2"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset

 
\begin_inset Formula $p=p-1$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndIf
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndIf
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndIf
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Permutation calculation
\end_layout

\begin_layout Standard
The next phase in algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Reorder-Matrix-Diagonal"

\end_inset

, described in step 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:line:reorder-calculate-permutation"

\end_inset

, is to calculate the best permutation of the blocks defined by the previous
 step.
 This problem is equivalent to finding a method for swapping adjacent elements
 in 
\begin_inset Formula $q$
\end_inset

 to obtain a confluent permutation 
\begin_inset Formula $\hat{q}$
\end_inset

.
 A confluent permutation of n integers, 
\begin_inset Formula $q_{1},\ldots,q_{n}$
\end_inset

, is a permutation such that any repeated integers 
\begin_inset Formula $q_{i}$
\end_inset

 are next to each other.
 The permutation is agnostic to the order of the elements within the same
 block.
 The best confluent permutation is the one that requires a minimal number
 of swaps to transform 
\begin_inset Formula $q$
\end_inset

 to 
\begin_inset Formula $\hat{q}$
\end_inset

.
 Finding such a permutation is an NP-complete problem [ref to ch9], where
 the minimum number of swaps required to obtain a given confluent permutation
 is bounded above by 
\begin_inset Formula $\frac{n^{2}}{2}(1-\frac{1}{k})$
\end_inset

, where 
\begin_inset Formula $k$
\end_inset

 is the number of distinct 
\begin_inset Formula $q_{i}$
\end_inset

 (the number of different clusters).
\end_layout

\begin_layout Standard
The following method works well in practice: find the average index of the
 integers in q and then order the integers in q′ by ascending average index.
\end_layout

\begin_layout Section
Algorithm Design and Analysis
\end_layout

\begin_layout Standard
In this section we will cover the advancements and improvements made in
 designing and implementing the matrix polynomial calculation algorithm.
 The section covers algorithms for rclustering and reordering eigenvalues
 for matrices, applying the calculation functions using smaller blocks,
 and parallelism of some aspects that reduce the execution time of the algorithm.
\end_layout

\begin_layout Subsection
Eigenvalues reordering - Smart Swapping vs.
 Bubble Sort
\end_layout

\begin_layout Standard
The final step in the reordering algorithm 
\begin_inset CommandInset ref
LatexCommand vref
reference "alg:Reorder-Matrix-Diagonal"

\end_inset

 (described in step 
\begin_inset CommandInset ref
LatexCommand ref
reference "lst:line:reorder-apply"

\end_inset

) applies the chosen permutation on the input triangular matrix 
\begin_inset Formula $T$
\end_inset

.
\end_layout

\begin_layout Standard
Swapping two adjacent diagonal elements of 
\begin_inset Formula $T$
\end_inset

 is implemented in LAPACK’s function 
\shape italic
?TRSEN
\shape default
 with computational cost of 
\begin_inset Formula $20n$
\end_inset

 flops for the complex flavor and 
\begin_inset Formula $6n$
\end_inset

 flops for the real flavor, plus another identical number of flops to update
 the Schur vectors matrix.
 A more robust LAPACK function 
\shape italic
?TREXC
\shape default
, introduced by Bai/Demmel (1993) [XXX ref], allows transferring an element
 from one index to another, by repetitively swapping adjacent blocks.
 Thus, all the element in between the source and target indices are shifted.
 This function also handles matrices in real-schur-form, meaning moving
 1-by-1 or 2-by-2 blocks to other indices of existing 1-by-1 or 2-by-2 blocks.
 The computational cost of this function is the product of the cost for
 swapping, and the number of swaps.
\end_layout

\begin_layout Standard
As it appears from the evaluation shown below, this step is computationally
 heavy, so the number of swaps must be minimized to achieve better and competiti
ve results.
\end_layout

\begin_layout Standard
A “naive” reordering can be implemented by applying the bubble-sort approach
 to swap adjacent diagonal elements, until they are located in their designated
 blocks.
 The swapping operation can be applied by either 
\shape italic
?TRSEN
\shape default
 or 
\shape italic
?TREXC
\shape default
.
 This approach does not yield the best results, as seen in the evaluation.
\end_layout

\begin_layout Standard
To reduce the number of swaps needed, a smart reordering has so be applied,
 which calculates the series of required swaps in advance.
 As the swapping operation of diagonal blocks is computationally expensive,
 the sorting operation can be applied on the elements indices, creating
 the desired order of blocks inside each cluster.
 Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Permute-cluster-blocks"

\end_inset

 generates a list of ordered diagonal blocks, given an ordered list 
\begin_inset Formula $c_{1},\ldots,c_{k}$
\end_inset

 of 
\begin_inset Formula $k$
\end_inset

 clusters (the chosen permutation mentioned above) and a list of the 
\begin_inset Formula $m$
\end_inset

 input blocks 
\begin_inset Formula $b_{1},...,b_{m}$
\end_inset

.
 Each block 
\begin_inset Formula $b_{i}$
\end_inset

 belong to one of the clusters 
\begin_inset Formula $c_{1},\ldots,c_{k}$
\end_inset

.
 We denote that block 
\begin_inset Formula $b_{i}$
\end_inset

 belongs to cluster 
\begin_inset Formula $c_{j}$
\end_inset

 as 
\begin_inset Formula $b_{i}\in c_{j}$
\end_inset

, and denote 
\begin_inset Formula $c_{b_{i}}$
\end_inset

 as 
\begin_inset Formula $c_{j}$
\end_inset

 for 
\begin_inset Formula $j$
\end_inset

 where 
\begin_inset Formula $b_{i}\in c_{j}$
\end_inset

.
\end_layout

\begin_layout Standard
The algorithm generates the ordered list by sorting the input blocks according
 to the input clusters order 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $c_{1},\ldots,c_{k}$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
.
 The required permutation, calculated by algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Block-pattern"

\end_inset

, does not indicate where the 2-by-2 blocks are located inside each cluster.
 So, within a cluster, the location of every block type (1-by-1 or 2-by-2)
 is set, while the algorithm is agnostic to the specific block that will
 be placed in each location.
\end_layout

\begin_layout Standard
For example, assume the input diagonal blocks are clustered as 3,1,4,2,3,2,2,1
 with sizes 1,2,2,1,2,1,2,2 respectively, and the clusters are sorted 4,3,1,2.
 The algorithm will output the ordered blocks to be clustered 4,3,3,1,1,2,2,2
 with sizes respectively 2,1,2,2,2,1,1,2.
\end_layout

\begin_layout Standard
The algorithm operates by bubble-sorting the input blocks according to the
 given permutation.
 In the “naive” reordering, the swapping operation would swap adjacent diagonal
 blocks in the matrix, while in the smart reordering will just swap their
 references without performing the actual replacement.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Permute cluster blocks
\begin_inset CommandInset label
LatexCommand label
name "alg:Permute-cluster-blocks"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
The algorithm generates the ordered list by sorting the input blocks according
 to the input clusters order 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $c_{1},\ldots,c_{k}$
\end_inset

.
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}[1]
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset

 
\begin_inset Formula $s=m$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
While{$s>0$}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset

 
\begin_inset Formula $t=0$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
For{$j=i+1:n$}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset

 Denote 
\begin_inset Formula $c_{b_{i-1}}$
\end_inset

 the cluster that contains 
\begin_inset Formula $b_{i-1}$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset

 Denote 
\begin_inset Formula $c_{b_{i}}$
\end_inset

 the cluster that contains 
\begin_inset Formula $b_{i}$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
If{$q_{i-1} > q_{i}$}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset

 Swap 
\begin_inset Formula $b_{i-1}\longleftrightarrow b_{i}$
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Comment
\end_layout

\end_inset

 Blocks are misplaced
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset

 
\begin_inset Formula $t=i$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndIf
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset

 
\begin_inset Formula $s=t$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndWhile
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\end_inset

Given the ordered blocks indices
\begin_inset Formula $ob_{1},\ldots,ob_{m}$
\end_inset

 generated by algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Permute-cluster-blocks"

\end_inset

, the series of required moves can be generated.
 We denote the size of block 
\begin_inset Formula $b_{i}$
\end_inset

 to be 
\begin_inset Formula $s_{b_{i}}$
\end_inset

.
 Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Reorder-misplaced-blocks"

\end_inset

 first classifies each input block 
\begin_inset Formula $ob_{j}$
\end_inset

 to be either misplaced or well-placed, according to the ordered blocks
 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $ob_{1},\ldots,ob_{m}$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 clusters and sizes.
\end_layout

\begin_layout Standard
For example, if 
\begin_inset Formula $b_{i}$
\end_inset

 is a 2-by-2 block of cluster 
\begin_inset Formula $j$
\end_inset

 and 
\begin_inset Formula $ob_{i}$
\end_inset

 is also a 2-by-2 block of cluster 
\begin_inset Formula $j$
\end_inset

 - then 
\begin_inset Formula $b_{i}$
\end_inset

 is well placed.
 Otherwise, if the block is of the wrong size (
\begin_inset Formula $s_{b_{i}}\neq s_{ob_{i}}$
\end_inset

) or of the wrong cluster (
\begin_inset Formula $c_{b_{i}}\neq c_{ob_{i}}$
\end_inset

), it is considered as misplaced.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Classify eigenvalue blocks
\begin_inset CommandInset label
LatexCommand label
name "alg:Classify-eigenvalue-blocks"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
The algorithm classifies each block to be well-placed or misplaced, according
 to the given permutation
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}[1]
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset

 Initialize sets for storing good locations and bad locations:
\begin_inset Formula $G=\emptyset,B=\emptyset$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset

 Initialize a list of output moves to be empty: 
\begin_inset Formula $moves=[]$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
For{$i=1:m$}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset

 Denote 
\begin_inset Formula $c_{ob_{i}}$
\end_inset

 the cluster that contains 
\begin_inset Formula $ob_{i}$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset

 Denote 
\begin_inset Formula $c_{b_{i}}$
\end_inset

 the cluster that contains 
\begin_inset Formula $b_{i}$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
If{$c_{b_{i}} 
\backslash
neq c_{ob_{i}} or s_{b_{i}} 
\backslash
neq s_{ob_{i}}$}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset

 Append 
\begin_inset Formula $b_{i}$
\end_inset

 to 
\begin_inset Formula $B$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Else
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset

 Append 
\begin_inset Formula $b_{i}$
\end_inset

 to 
\begin_inset Formula $G$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndIf
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\end_inset

Then, the algorithm iterates over the misplaced blocks list, and finds a
 candidate 
\begin_inset Formula $b_{i}$
\end_inset

 for each location 
\begin_inset Formula $j$
\end_inset

 containing a misplaced block 
\begin_inset Formula $b_{j}$
\end_inset

.
 The iteration is done in ascending order over the locations.
 Therefore, all the blocks before the current location in each iteration
 are well-placed by previous iterations.
 By moving 
\begin_inset Formula $b_{j}$
\end_inset

 to location 
\begin_inset Formula $i$
\end_inset

, all blocks in between 
\begin_inset Formula $i$
\end_inset

 and 
\begin_inset Formula $j$
\end_inset

 locations are shifted.
 The algorithm re-classifies them as misplaced or well-placed as needed.
\end_layout

\begin_layout Standard
Note that no blocks before location 
\begin_inset Formula $j$
\end_inset

 are shifted, as they are already well-placed.
 So, the maximal number of moves is 
\begin_inset Formula $m$
\end_inset

 at most.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Reorder misplaced blocks
\begin_inset CommandInset label
LatexCommand label
name "alg:Reorder-misplaced-blocks"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
The algorithm finds and reorders the misplaced blocks
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}[1]
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Require
\end_layout

\end_inset

 
\begin_inset Formula $B,G$
\end_inset

 sets generated by algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Classify-eigenvalue-blocks"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
While{$B 
\backslash
neq 
\backslash
emptyset$}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset

 Denote by 
\begin_inset Formula $b_{j}$
\end_inset

 a block from 
\begin_inset Formula $B$
\end_inset

 with the minimal index
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset

 Get a location candidate 
\begin_inset Formula $i$
\end_inset

 such that 
\begin_inset Formula $b_{i}\in B$
\end_inset

, 
\begin_inset Formula $c_{b_{i}}=c_{ob_{j}}$
\end_inset

 and 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $s_{b_{i}}=s_{ob_{j}}$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Comment
\end_layout

\end_inset

 The block 
\begin_inset Formula $b_{i}$
\end_inset

 is misplaced, it belongs to the cluster that should be placed in 
\begin_inset Formula $j$
\end_inset

 location and has the required block size to be placed in 
\begin_inset Formula $j$
\end_inset

 location.
 Note that 
\begin_inset Formula $j<i$
\end_inset

 as 
\begin_inset Formula $j$
\end_inset

 is the minimal index in 
\begin_inset Formula $B$
\end_inset

 by its definition
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset

 
\begin_inset Formula $moves=moves+(b_{i},b_{j})$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset

 
\begin_inset Formula $B=B\setminus\{b_{j}\}$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset

 
\begin_inset Formula $nB=\emptyset$
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Comment
\end_layout

\end_inset

 New misplaced blocks
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
For{$k=j:i$}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset

 Take the block 
\begin_inset Formula $b_{k}$
\end_inset

 either from 
\begin_inset Formula $B$
\end_inset

 or 
\begin_inset Formula $G$
\end_inset

.
 Remove it from 
\begin_inset Formula $B$
\end_inset

 if exists in it.
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
If{$c_{ob_{k+1}} 
\backslash
neq c_{b_{k}} or s_{ob_{k+1}} 
\backslash
neq s_{b_{k}}$}
\end_layout

\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Comment
\end_layout

\end_inset

 Check if moving 
\begin_inset Formula $b_{k}$
\end_inset

 to index 
\begin_inset Formula $k+1$
\end_inset

, results a new misplaced or well-placed block
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset

 Append 
\begin_inset Formula $b_{k}$
\end_inset

 to 
\begin_inset Formula $nB$
\end_inset

 as 
\begin_inset Formula $k+1$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Else
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset

 Append 
\begin_inset Formula $b_{k}$
\end_inset

 to 
\begin_inset Formula $G$
\end_inset

 as 
\begin_inset Formula $k+1$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndIf
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset

 
\begin_inset Formula $B=B\cup nB$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndWhile
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\end_inset

Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Reorder-misplaced-blocks"

\end_inset

 places the required block in the minimal misplaced location in each iteration.
 The required block originates from a location after the minimal misplaced
 location (otherwise, the minimal misplaced location will not be minimal).
 Each replacement shifts the block between the source and target locations,
 so no blocks located before the minimal misplaced location are moved.
 By assuring that the algorithm does not spoil any well-placed blocks in
 each iteration, the number of swaps performed by the smart reordering is
 at most 
\begin_inset Formula $m$
\end_inset

, while each swap moves a block 
\begin_inset Formula $m$
\end_inset

 steps at most.
\end_layout

\begin_layout Subsubsection
Reordering overview
\end_layout

\begin_layout Standard
The reordering algorithm can be summarized as follows:
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Reorder matrix by clusters
\begin_inset CommandInset label
LatexCommand label
name "alg:Reorder-matrix-by"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
This algorithm expands algorithm 
\begin_inset CommandInset ref
LatexCommand vref
reference "alg:Reorder-Matrix-Diagonal"

\end_inset

 using the algorithms described above.
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}[1]
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset

 Based on the locations of the blocks belong to each cluster, build a permutatio
n 
\begin_inset Formula $p$
\end_inset

 that optimizes the number of swaps required to transform the input list
 into that permutation, using algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Permute-cluster-blocks"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset

 Cluster the input 
\begin_inset Formula $m$
\end_inset

 eigenvalue blocks by according to the blocking parameter 
\begin_inset Formula $\delta>0$
\end_inset

 using algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Block-pattern"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset

 Use algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Classify-eigenvalue-blocks"

\end_inset

 to classify all blocks as well-placed or misplaced.
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset

 Use algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Reorder-misplaced-blocks"

\end_inset

 to build reordering moves by iterating over the misplaced locations in
 ascending order, and fixing each location by placing a candidate block
 from a higher index in each iteration.
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset

 Apply the moves generated by algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Reorder-misplaced-blocks"

\end_inset

 to reorder the diagonal blocks of the input triangular matrix.
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The asymptotic cost of both approaches, the native reordering and the smart
 reordering, is almost the same.
 The smart permutation works faster under the evaluation shown below.
 
\end_layout

\begin_layout Subsection
Calculate Parlett Recurrence
\end_layout

\begin_layout Standard
After the diagonal blocks are clustered and reordered, the required polynomial
 calculation can be performed directly on each diagonal cluster.
 There is no point in splitting the clusters into smaller chunks, because
 the eigenvalues are too close (thus they are located in the same clusters),
 and the calculation may be numerically unstable.
\end_layout

\begin_layout Standard
After the polynomial function is calculated for all the diagonal blocks
 clusters, the function has to be applied for all the other elements in
 the triangular matrix, that are located outside the diagonal blocks.
 This is done by using Parlett Recurrence (algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Block-pattern"

\end_inset

).
 This recurrence can be used to compute 
\begin_inset Formula $F$
\end_inset

 either a block superdiagonal at a time or a block column at a time, provided
 we can evaluate the diagonal blocks 
\begin_inset Formula $F_{ii}=f(T_{ii})$
\end_inset

 and solve the Sylvester equations 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:parlett_block_sylvester"

\end_inset

 for the 
\begin_inset Formula $F_{ij}$
\end_inset

.
 We analyze those two approaches for calculating the recurrence.
\end_layout

\begin_layout Subsubsection
Superdiagonal iterations
\begin_inset CommandInset label
LatexCommand label
name "subsec:Superdiagonal-iterations"

\end_inset


\end_layout

\begin_layout Standard
Assume the polynomial was calculated for the diagonal clusters, as shown
 in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Iteration-#0"

\end_inset

.
 The diagonal cluster blocks are the first layer of blocks calculated.
 In each iteration, the superdiagonal algorithm takes the next layer of
 blocks on the superdiagonal adjacent to the one from the previous iteration
 (figure 
\begin_inset CommandInset ref
LatexCommand eqref
reference "fig:Iteration-#1"

\end_inset

), and applies the Parlett Recurrence 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:parlett_block_sylvester"

\end_inset

 to calculate the blocks in that layer.
 Each block 
\begin_inset Formula $F_{ij}$
\end_inset

 is calculated as described in algorithm 
\begin_inset CommandInset ref
LatexCommand eqref
reference "alg:Block-Parlett-Recurrence"

\end_inset

, using the values in the blocks below it and on its left side (figure 
\begin_inset CommandInset ref
LatexCommand eqref
reference "fig:Iteration-#2"

\end_inset

)).
 Block 
\begin_inset Formula $F_{ij}$
\end_inset

 solves the Sylvester equation 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:parlett_block_sylvester"

\end_inset

.
 All 
\begin_inset Formula $T_{ab}$
\end_inset

 blocks are known, as 
\begin_inset Formula $T$
\end_inset

 is real-schur-form of the input triangular matrix, and only already-calculated
 
\begin_inset Formula $F_{cd}$
\end_inset

 blocks are used.
\end_layout

\begin_layout Standard
Therefore, calculating each block on the superdiagonal is independent from
 the other blocks on the same superdiagonal, meaning that all blocks on
 the same superdiagonal can be calculated in parallel to one another (figure
 
\begin_inset CommandInset ref
LatexCommand eqref
reference "fig:Iteration-#2"

\end_inset

) 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename recurrence_1_1.png
	scale 20

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Iteration #0
\begin_inset CommandInset label
LatexCommand label
name "fig:Iteration-#0"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float figure
wide true
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename recurrence_1_1_1.png
	scale 20

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Iteration #1
\begin_inset CommandInset label
LatexCommand label
name "fig:Iteration-#1"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float figure
wide true
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename recurrence_1_2.png
	scale 20

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Iteration #2
\begin_inset CommandInset label
LatexCommand label
name "fig:Iteration-#2"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float figure
wide true
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename recurrence_1_3.png
	scale 20

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Iteration #3
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Superdiagonal iterations
\begin_inset CommandInset label
LatexCommand label
name "fig:Superdiagonal-iterations"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset

The algorithm for superdiagonal iterations requires to change algorithm
 
\begin_inset CommandInset ref
LatexCommand eqref
reference "alg:Block-Parlett-Recurrence"

\end_inset

 (
\begin_inset CommandInset ref
LatexCommand nameref
reference "alg:Block-Parlett-Recurrence"

\end_inset

) and is described in algorithm
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Superdiagonal Block Parlett Recurrence
\begin_inset CommandInset label
LatexCommand label
name "alg:Superdiagonal-Block-Parlett"

\end_inset


\end_layout

\end_inset

Given a triangular matrix 
\begin_inset Formula $T=(Tij)\in\mathbb{C}^{n\times n}$
\end_inset

 partitioned in block form, with no two diagonal blocks having an eigenvalue
 in common, and a function 
\begin_inset Formula $f$
\end_inset

 defined on the spectrum of 
\begin_inset Formula $T$
\end_inset

, this algorithm computes 
\begin_inset Formula $F=f(T)$
\end_inset

 using the block form of Parlett’s recurrence using the superdiagonal approach
 demonstrated in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Superdiagonal-iterations"

\end_inset

.
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}[1]
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset

 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $F_{ii}=f(T_{ii})$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 - Calculate function 
\begin_inset Formula $f$
\end_inset

 for all diagonal blocks
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
For{$d=2:n$}
\end_layout

\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Comment
\end_layout

\end_inset

 Those are the superdiagonal layers
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
For{$i=1:n-d$}
\end_layout

\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Comment
\end_layout

\end_inset

 Run in parallel over all range 
\begin_inset Formula $1\ldots n-d$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset

 
\begin_inset Formula $j\gets i+d$
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Comment
\end_layout

\end_inset

 This is the column for superdiagonal 
\begin_inset Formula $d$
\end_inset

 in row 
\begin_inset Formula $i$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset

 Solve the Sylvester equation 
\begin_inset Formula $T_{ii}F_{ij}\text{−}F_{ij}T_{jj}=F_{ii}T_{ij}\text{−}T_{ij}F_{jj}+\sum_{k=i+1}^{j\text{−}1}(F_{ik}T_{kj}\text{−}T_{ik}F_{kj})$
\end_inset

 for 
\begin_inset Formula $F_{ij}$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\end_inset

 
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Sequential iterations
\begin_inset CommandInset label
LatexCommand label
name "subsec:Sequential-iterations"

\end_inset


\end_layout

\begin_layout Standard
After the polynomial is calculated for the diagonal cluster blocks (figure
 
\begin_inset CommandInset ref
LatexCommand eqref
reference "fig:seq-Iteration-#0"

\end_inset

) marked as A-blocks, Parlett Recurrence can be applied to calculate the
 top-left non-diagonal block (figure 
\begin_inset CommandInset ref
LatexCommand eqref
reference "fig:seq-Iteration-#1"

\end_inset

) marked as B block.
 After B-block is calculated, the block adjacent to it (figure 
\begin_inset CommandInset ref
LatexCommand eqref
reference "fig:seq-Iteration-#2"

\end_inset

) can be calculated (marked as C block), as the Sylvester equation that
 it solves, contains only A and B blocks (figures 
\begin_inset CommandInset ref
LatexCommand eqref
reference "fig:seq-Iteration-#3"

\end_inset

,
\begin_inset CommandInset ref
LatexCommand eqref
reference "fig:seq-Iteration-#4"

\end_inset

).
 This approach solves less Sylvester equations (
\begin_inset Formula $O(m)$
\end_inset

, opposed to 
\begin_inset Formula $O(m^{2})$
\end_inset

 in the superdiagonal algorithm) where each Sylvester equation contains
 larger-scale matrices.
\end_layout

\begin_layout Standard
The calculation of the block in each iteration relies on the blocks calculated
 before it, so this approach is sequential and cannot be paralleled.
\end_layout

\begin_layout Standard
The Sylvester equation solver algorithm can be paralleled internally, as
 shown in algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Blocked-recursive-Sylvester"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename recurrence_2_1.png
	scale 20

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Iteration #0
\begin_inset CommandInset label
LatexCommand label
name "fig:seq-Iteration-#0"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename recurrence_2_2.png
	scale 20

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Iteration #1
\begin_inset CommandInset label
LatexCommand label
name "fig:seq-Iteration-#1"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename recurrence_2_3.png
	scale 20

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Iteration #2
\begin_inset CommandInset label
LatexCommand label
name "fig:seq-Iteration-#2"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename recurrence_2_4.png
	scale 20

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Iteration #3
\begin_inset CommandInset label
LatexCommand label
name "fig:seq-Iteration-#3"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename recurrence_2_5.png
	scale 20

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Iteration #4
\begin_inset CommandInset label
LatexCommand label
name "fig:seq-Iteration-#4"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Sequential iterations
\begin_inset CommandInset label
LatexCommand label
name "fig:Sequential-iterations"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset

Algorithm descibes the operation of the sequential approach.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Sequential iterations
\begin_inset CommandInset label
LatexCommand label
name "alg:Sequential-iterations"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Given a triangular matrix 
\begin_inset Formula $T=(Tij)\in\mathbb{C}^{n\times n}$
\end_inset

 partitioned in block form, with no two diagonal blocks having an eigenvalue
 in common, and a function 
\begin_inset Formula $f$
\end_inset

 defined on the spectrum of 
\begin_inset Formula $T$
\end_inset

, this algorithm computes 
\begin_inset Formula $F=f(T)$
\end_inset

 using the block form of Parlett’s recurrence using the sequential approach
 demonstrated in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Sequential-iterations"

\end_inset

.
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}[1]
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset

 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $F_{ii}=f(T_{ii})$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 - Calculate function 
\begin_inset Formula $f$
\end_inset

 for all diagonal blocks
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
For{$i=2:n$}
\end_layout

\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Comment
\end_layout

\end_inset

 Those are sequential blocks.
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset

 Denote 
\begin_inset Formula $F_{i}$
\end_inset

 the 
\begin_inset Formula $i$
\end_inset

-th top-left non-diagonal block.
 Denote 
\begin_inset Formula $F_{ii}$
\end_inset

,
\begin_inset Formula $T_{ii}$
\end_inset

 the diagonal blocks of 
\begin_inset Formula $F,T$
\end_inset

 in index 
\begin_inset Formula $i$
\end_inset

.
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset

 Let 
\begin_inset Formula $F_{jj}$
\end_inset

 be the sub-matrix of 
\begin_inset Formula $F$
\end_inset

 with blocks 
\begin_inset Formula $1,\dots,i-1$
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Comment
\end_layout

\end_inset

 This is the triangular block on the left side of the current calculated
 block
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset

 Let 
\begin_inset Formula $T_{jj}$
\end_inset

 be the sub-matrix of 
\begin_inset Formula $T$
\end_inset

 with blocks 
\begin_inset Formula $1,\dots,i-1$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset

 Solve the Sylvester equation 
\begin_inset Formula $T_{ii}F_{i}\text{−}F_{i}T_{jj}=F_{ii}T_{ij}\text{−}T_{ij}F_{jj}$
\end_inset

 for 
\begin_inset Formula $F_{i}$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\end_inset

 
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Blocked Recursive Sylvester Solver
\end_layout

\begin_layout Standard
The recursive algorithm 
\begin_inset CommandInset ref
LatexCommand nameref
reference "alg:Blocked-recursive-Sylvester"

\end_inset

 
\begin_inset CommandInset ref
LatexCommand eqref
reference "alg:Blocked-recursive-Sylvester"

\end_inset

 
\begin_inset CommandInset ref
LatexCommand vpageref
reference "alg:Blocked-recursive-Sylvester"

\end_inset

 for solving Sylvester equations, operates by recursively splitting the
 dimensions of the matrices, calculating their solutions, and unifying the
 calculated results together [ref to article].
 Some of the recursive steps can be paralleled, as their are independent
 to one another.
 This implementation had empirically better results than the straight-forward
 LAPACK version 
\shape italic
?TRSYL
\shape default
.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Blocked recursive Sylvester solver
\begin_inset CommandInset label
LatexCommand label
name "alg:Blocked-recursive-Sylvester"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
The algorithm recursively and concurrently solves Sylvester equation based
 on the input matrices
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}[1]
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Ensure
\end_layout

\end_inset

 
\begin_inset Formula $A\in\mathbb{R}^{n\times n}$
\end_inset

and 
\begin_inset Formula $B\in\mathbb{R}^{m\times m}$
\end_inset

 in upper quasi-triangular (Schur) form.
 
\begin_inset Formula $C\in\mathbb{R}^{n\times m}$
\end_inset

 dense matrix.
 
\begin_inset Formula $blks$
\end_inset

 is the maximal block size to use an algorithm for solving small-sized triangula
r Sylvester equation.
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Ensure
\end_layout

\end_inset

 Function 
\begin_inset Formula $GEMM$
\end_inset

 implements the 
\begin_inset Formula $GEMM$
\end_inset

-operation 
\begin_inset Formula $C=C+A\cdot B$
\end_inset

.
 Function 
\begin_inset Formula $TRSYLV$
\end_inset

 implements an algorithm for solving triangular Sylvester kernel problems.
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Function{rtrsylv}{$A,B,C,blks$}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
If{$1 
\backslash
le M,N 
\backslash
le blks$}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset

 
\begin_inset Formula $X=$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Call{trsylv}{$A,B,C$}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ElsIf{$1 
\backslash
le M 
\backslash
le 
\backslash
frac{N}{2}$}
\end_layout

\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Comment
\end_layout

\end_inset

 Case 1: Split 
\begin_inset Formula $A$
\end_inset

 by rows and columns and 
\begin_inset Formula $C$
\end_inset

 by rows only
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset

 
\begin_inset Formula $X_{2}=$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Call{rtrsylv}{$A_{22},B,C_{2},blks$}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset

 
\begin_inset Formula $C_{1}=$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Call{gemm}{$-A_{12},X_{2},C_{1}$}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset

 
\begin_inset Formula $X_{1}=$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Call{rtrsylv}{$A_{11},B,C_{1},blks$}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset

 
\begin_inset Formula $X=\begin{bmatrix}X_{1}\\
X_{2}
\end{bmatrix}$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ElsIf{$1 
\backslash
le N 
\backslash
le 
\backslash
frac{M}{2}$}
\end_layout

\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Comment
\end_layout

\end_inset

 Case 2: Split 
\begin_inset Formula $B$
\end_inset

 by rows and columns and 
\begin_inset Formula $C$
\end_inset

 by columns only
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset

 
\begin_inset Formula $X_{1}=$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Call{rtrsylv}{$A,B_{11},C_{1},blks$}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset

 
\begin_inset Formula $C_{2}=$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Call{gemm}{$X_{1},B_{12},C_{2}$}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset

 
\begin_inset Formula $X_{2}=$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Call{rtrsylv}{$A,B_{22},C_{2},blks$}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset

 
\begin_inset Formula $X=\begin{bmatrix}X_{1} & X_{2}\end{bmatrix}$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Else
\end_layout

\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Comment
\end_layout

\end_inset

 Case 3: Split 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $B$
\end_inset

 and 
\begin_inset Formula $C$
\end_inset

 by rows and columns
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset

 
\begin_inset Formula $X_{21}=$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Call{rtrsylv}{$A_{22},B_{11},C_{21},blks$}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset

 
\begin_inset Formula $C_{22}=$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Call{gemm}{$X_{21},B_{12},C_{22}$}
\end_layout

\end_inset

,
\begin_inset Formula $C_{11}=$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Call{gemm}{$-A_{12},X_{21},C_{11}$}
\end_layout

\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Comment
\end_layout

\end_inset

 Run in parallel
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset

 
\begin_inset Formula $X_{22}=$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Call{rtrsylv}{$A_{22},B_{22},C_{22},blks$}
\end_layout

\end_inset

,
\begin_inset Formula $X_{11}=$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Call{rtrsylv}{$A_{11},B_{11},C_{11},blks$}
\end_layout

\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Comment
\end_layout

\end_inset

 Run in parallel
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset

 
\begin_inset Formula $C_{12}=$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Call{gemm}{$-A_{12},X_{22},C_{12}$}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset

 
\begin_inset Formula $C_{12}=$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Call{gemm}{$X_{11},B_{12},C_{12}$}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset

 
\begin_inset Formula $X_{12}=$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Call{rtrsylv}{$A_{11},B_{22},C_{12},blks$}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset

 
\begin_inset Formula $X=\begin{bmatrix}X_{11} & X_{12}\\
X_{21} & X_{22}
\end{bmatrix}$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndIf
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndFunction
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Schur-Parlett algorithm
\end_layout

\begin_layout Standard
The complete algorithm for calculating the polynomial
\begin_inset Formula $q(A)$
\end_inset

 is described in algorithm 
\begin_inset CommandInset ref
LatexCommand nameref
reference "alg:Schur-Parlett-algorithm-for"

\end_inset

 
\begin_inset CommandInset ref
LatexCommand eqref
reference "alg:Schur-Parlett-algorithm-for"

\end_inset

 
\begin_inset CommandInset ref
LatexCommand vpageref
reference "alg:Schur-Parlett-algorithm-for"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Schur-Parlett algorithm for 
\begin_inset Formula $q(A)$
\end_inset


\begin_inset CommandInset label
LatexCommand label
name "alg:Schur-Parlett-algorithm-for"

\end_inset


\end_layout

\end_inset

Given 
\begin_inset Formula $A\in\mathbb{R}^{n\times n}$
\end_inset

 and a polynomial 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $q(A)=\sum_{k=0}^{m}c_{k}\cdot A^{k}$
\end_inset

 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:polynomial-def"

\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
, this algorithm computes 
\begin_inset Formula $F=q(A)$
\end_inset

.
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}[1]
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset

 Compute the real-form Schur decomposition 
\begin_inset Formula $A=QTQ^{∗}$
\end_inset

 (
\begin_inset Formula $Q$
\end_inset

 unitary, 
\begin_inset Formula $T$
\end_inset

 upper quasi-triangular).
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
If{$T$ is diagonal}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset

 
\begin_inset Formula $F=q(T)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset

 go-to line 
\begin_inset CommandInset ref
LatexCommand eqref
reference "lst:line:get-qfq"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndIf
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset

 Using Algorithm 
\begin_inset CommandInset ref
LatexCommand eqref
reference "alg:Block-pattern"

\end_inset

 with blocking parameter 
\begin_inset Formula $\delta=0.1$
\end_inset

, assign each eigenvalue 
\begin_inset Formula $\lambda_{i}$
\end_inset

 to a set 
\begin_inset Formula $S_{q_{i}}$
\end_inset

.
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset

 Choose a confluent permutation 
\begin_inset Formula $\hat{q}$
\end_inset

 of 
\begin_inset Formula $q$
\end_inset

 ordered by average index, and use algorithm 
\begin_inset CommandInset ref
LatexCommand eqref
reference "alg:Permute-cluster-blocks"

\end_inset

 to apply the permutation.
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset

 Reorder 
\begin_inset Formula $T$
\end_inset

 according to 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\hat{q}$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 using the smart permutation algorithm 
\begin_inset CommandInset ref
LatexCommand eqref
reference "alg:Reorder-matrix-by"

\end_inset

, and update 
\begin_inset Formula $Q$
\end_inset

.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Comment
\end_layout

\end_inset

 Now 
\begin_inset Formula $A=QTQ^{∗}$
\end_inset

 is a reordered Schur decomposition, with 
\begin_inset Formula $m$
\end_inset

 diagonal clustered blocks in 
\begin_inset Formula $T$
\end_inset

.
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset

 Apply Parlett Recurrence using either of 
\begin_inset CommandInset ref
LatexCommand nameref
reference "subsec:Superdiagonal-iterations"

\end_inset

 or 
\begin_inset CommandInset ref
LatexCommand nameref
reference "subsec:Sequential-iterations"

\end_inset

 techniques.
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset

 
\begin_inset Formula $F=Q\cdot F\cdot Q^{*}$
\end_inset

 
\begin_inset CommandInset label
LatexCommand label
name "lst:line:get-qfq"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Implementation
\end_layout

\begin_layout Standard
We implemented the algorithms described above using Intel® Parallel Studio
 XE 2018 for Windows, under C++ 14 standards using Visual Studio 2017 IDE
 and Intel
\begin_inset script superscript

\begin_layout Plain Layout
®
\end_layout

\end_inset

 C++ Compiler 18.0 for Windows.
 The LAPACK functions used are also part of the Intel Parallel Studio package,
 specifically from Intel MKL library.
 [ref to GitHub]
\end_layout

\begin_layout Subsection
Parallelism
\end_layout

\begin_layout Standard
The parallelism was done using Intel
\begin_inset script superscript

\begin_layout Plain Layout
®
\end_layout

\end_inset

 Cilk™ Plus library integrated with Intel Parallel Studio package, on the
 following algorithms:
\end_layout

\begin_layout Enumerate
Calculate the sum of two matrices by calculating the sum of every element
 in parallel (using array notations)
\end_layout

\begin_deeper
\begin_layout Enumerate
Adding matrix 
\begin_inset Formula $M$
\end_inset

 to current matrix 
\begin_inset Formula $this$
\end_inset

 in offset 
\begin_inset Formula $from$
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

cilk_for(int col = 0; col < M.ncols(); col++)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	this->data(from.first, from.second + col)[0:M.nrows()] += M.data(0, col)[0:M.nrows()
];
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Multiply a matrix by a scalar, by calculating the product of every element
 in parallel
\end_layout

\begin_deeper
\begin_layout Enumerate
Scale current matrix 
\begin_inset Formula $this$
\end_inset

 in offset 
\begin_inset Formula $from$
\end_inset

 by scalar 
\begin_inset Formula $alpha$
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

cilk_for(int col = 0; col < n; col++)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	this->data(from.first, from.second + col)[0:m] *= alpha;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Apply the polynomial calculation using Patterson-Stockmeyer algorithm as
 described in equation 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:ps-polynomial"

\end_inset

 
\begin_inset CommandInset ref
LatexCommand vpageref
reference "eq:ps-polynomial"

\end_inset

.
 Every 
\begin_inset Formula $p-1$
\end_inset

-degree polynomial can be calculated in parallel, using the cached 
\begin_inset Formula $A^{2},...,A^{p-1}$
\end_inset

 matrices.
 The final polynomial is calculated using Horner's method as described in
 algorithm 
\begin_inset CommandInset ref
LatexCommand vref
reference "alg:horner_rule"

\end_inset

, sequentially.
\end_layout

\begin_deeper
\begin_layout Enumerate
Given the polynomial 
\begin_inset Formula $coefficients$
\end_inset

 (degree 
\begin_inset Formula $d$
\end_inset

), calculate the polynomial using Patterson-Stockmeyer algorithm.
 Assume 
\begin_inset Formula $Aps$
\end_inset

 contains all powers of 
\begin_inset Formula $A^{2},...,A^{p-1}$
\end_inset

 and 
\begin_inset Formula $Ap=A^{p}$
\end_inset

.
 Each iteration calculatation is stored in 
\begin_inset Formula $pPolynomial$
\end_inset

 and added to the final 
\begin_inset Formula $qA$
\end_inset

 using Horner's rule (algorithm 
\begin_inset CommandInset ref
LatexCommand vref
reference "alg:horner_rule"

\end_inset

)
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

// Polynomial degree, including I (degree 0)
\end_layout

\begin_layout Plain Layout

int d = coefficients.size();
\end_layout

\begin_layout Plain Layout

size_t p = (size_t)sqrt(d);
\end_layout

\begin_layout Plain Layout

size_t s = (d + 1) / p; // d+1 = ps
\end_layout

\begin_layout Plain Layout

// Reverse order - Horner Rule
\end_layout

\begin_layout Plain Layout

for (int si = s - 1; si >= 0; si--) 
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	Matrix pPolynomial(n, n);
\end_layout

\begin_layout Plain Layout

	cilk_for (size_t i = 0; i < Aps.size(); i++)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		int pi = si * p + i;
\end_layout

\begin_layout Plain Layout

		Matrix Ai(Aps[i]);
\end_layout

\begin_layout Plain Layout

		Ai.multiply(coefficients[pi]);
\end_layout

\begin_layout Plain Layout

		pPolynomial.add(Ai); // pPolynomial += Ai
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	// qA = qA * Ap + pPolynomial
\end_layout

\begin_layout Plain Layout

	qA.multiply(Ap);
\end_layout

\begin_layout Plain Layout

	qA.add(pPolynomial, origin);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

return qA;
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Calculate the Sylvester equations using the recursive algorithm 
\begin_inset CommandInset ref
LatexCommand vref
reference "alg:Blocked-recursive-Sylvester"

\end_inset

, performing some of the calculations concurrently as described in the algorithm
 definition.
\end_layout

\begin_deeper
\begin_layout Enumerate
The following snippet shows the part of the parallel code using Cilk's syntax
 in algorithm 
\begin_inset CommandInset ref
LatexCommand vref
reference "alg:Blocked-recursive-Sylvester"

\end_inset

 (case 3)
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

auto X21 = rtrsylv(A22, B11, C21, block_size);
\end_layout

\begin_layout Plain Layout

cilk_spawn Matrix::multiply_ex(X21, B12, C22, X21.nrows(), B12.ncols(), X21.ncols()
);
\end_layout

\begin_layout Plain Layout

A12.multiply(-1);
\end_layout

\begin_layout Plain Layout

Matrix::multiply_ex(A12, X21, C11, A12.nrows(), X21.ncols(), A12.ncols());
\end_layout

\begin_layout Plain Layout

cilk_sync;
\end_layout

\begin_layout Plain Layout

auto X22 = cilk_spawn rtrsylv(A22, B22, C22, block_size);
\end_layout

\begin_layout Plain Layout

auto X11 = rtrsylv(A11, B11, C11, block_size);
\end_layout

\begin_layout Plain Layout

cilk_sync;
\end_layout

\begin_layout Plain Layout

Matrix::multiply_ex(A12, X22, C12, A12.nrows(), X22.ncols(), A12.ncols());
\end_layout

\begin_layout Plain Layout

Matrix::multiply_ex(X11, B12, C12, X11.nrows(), B12.ncols(), X11.ncols());
\end_layout

\begin_layout Plain Layout

auto X12 = rtrsylv(A11, B22, C12, block_size);
\end_layout

\begin_layout Plain Layout

auto X1 = Matrix::concat_cols(X11, X12);
\end_layout

\begin_layout Plain Layout

auto X2 = Matrix::concat_cols(X21, X22);
\end_layout

\begin_layout Plain Layout

return Matrix::concat_rows(X1, X2);
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Perform some eigenvalue clustering steps of algorithm 
\begin_inset CommandInset ref
LatexCommand eqref
reference "alg:Block-pattern"

\end_inset

 as described in lines 
\begin_inset CommandInset ref
LatexCommand eqref
reference "lst:line:cluster-max-to-min-1"

\end_inset

,
\begin_inset CommandInset ref
LatexCommand eqref
reference "lst:line:cluster-max-to-min-2"

\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

cilk_for (int m = 0; m < n; m++)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	// Move the elements of Smax(qi,qj) to Smin(qi,qj)
\end_layout

\begin_layout Plain Layout

	if (clusters[m] == max_qiqj)
\end_layout

\begin_layout Plain Layout

		clusters[m] = min_qiqj;
\end_layout

\begin_layout Plain Layout

	// Reduce by 1 the indices of sets Sq for q > max(qi, qj).
\end_layout

\begin_layout Plain Layout

	if (clusters[m] > max_qiqj)
\end_layout

\begin_layout Plain Layout

		clusters[m]--;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Apply Parlett Recurrence over superdiagonal blocks, as described in algorithm
 
\begin_inset CommandInset ref
LatexCommand vref
reference "alg:Superdiagonal-Block-Parlett"

\end_inset

 - calculate all the blocks that belong to the same superdiagonal concurrently.
\end_layout

\begin_layout Enumerate
Benchmarking the performance of the implementation requires precise timing
 of each step.
 The timings are accumulated using Cilk's reducer to support parallelism.
\end_layout

\begin_layout Standard
It is important to note that Patterson-Stockmeyer's algorithm was used,
 rather than Val-Loan's variation as described in [ref to Sivan's article].
 The Van-Loan algorithm exploits that parallelism of computing multiple
 columns concurrently, but still requires calculating and caching the explicit
 powers 
\begin_inset Formula $A^{2},\ldots,A^{p}\ldots,(A^{p})^{s}$
\end_inset

.
 Therefore, it will neither improve the parallelism of the algorithm, nor
 the storage requirements or floating-point calculations.
\end_layout

\begin_layout Standard
Intel MKL 2018 provides highly optimized, threaded, and vectorized math
 functions that maximize performance on Intel processor architectures.
 It is compatible across many different compilers, languages, operating
 systems, linking, and threading models.
 In particular, the Intel MKL 
\shape italic
?GEMM
\shape default
 function for matrix-matrix multiplication is highly tuned for small matrices.
 Intel MKL primitives take advantage of Intel Advanced Vector Extensions
 512 (Intel AVX-512) and the capabilities of the latest generations of the
 Intel Xeon Phi™ processors.
 
\shape italic
?GEMM
\shape default
 chooses the code path at runtime based on characteristics of the matrices
 and the underlying processor’s capabilities.
 As a result, applications that rely on 
\shape italic
?GEMM
\shape default
 automatically benefit from these optimizations without needing any modification
 of the code merely be relinking with Intel MKL.
 Thus, it is not necessary to implement a parallel-form of the matrix multiplica
tion operation, as 
\shape italic
?GEMM
\shape default
 is already highly optimized.
\end_layout

\begin_layout Standard

\strikeout on
In addition, parallel matrix multiplication implementations, such as Strassen
 algorithm (which uses 
\begin_inset Formula $O(n^{2.81})$
\end_inset

 flops), will not improve performance, as the polynomial calculation algorithm
 splits the input matrix into small matrix chunks.
 Strassen multiplies the matrix using 7 multiply operations and 18 add operation
s, while the naive multiplication uses 8 multiply operations and 7 add operation
s.
 For small matrix sizes/chunks, the overhead of Strassen-like multiplications
 overweights the advantage in parallelism.
\end_layout

\begin_layout Section
Evaluation
\end_layout

\begin_layout Standard
The implementation is parameterized and can use many variations.
 We will start with showing and analyzing of the best variant, and later
 analyze the impact of different parameters on the performance.
 For the optimal variation of the algorithm, we chose the following parameters:
\end_layout

\begin_layout Enumerate
Use real-schur-form decomposition as implemented in LAPACK library
\end_layout

\begin_layout Enumerate
Use the parallel superdiagonal variation of the Parlett Recurrence described
 in algorithm 
\begin_inset CommandInset ref
LatexCommand vref
reference "alg:Superdiagonal-Block-Parlett"

\end_inset


\end_layout

\begin_layout Enumerate
Use the blocked recursive/parallel variation of Sylvester solver described
 in algorithm 
\begin_inset CommandInset ref
LatexCommand vref
reference "alg:Blocked-recursive-Sylvester"

\end_inset


\end_layout

\begin_layout Enumerate
Use the smart reordering algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Reorder-matrix-by"

\end_inset

 to reorder the triangular matrix's eigenvalues according to the desired
 permutation of clusters.
\end_layout

\begin_layout Enumerate
Use default clustering tolerance of 
\begin_inset Formula $\lambda=0.005$
\end_inset

 (as large number of clusters is paralleled well)
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename performance_5_0_high.png
	width 50col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
High-degree polynomial evaulation
\begin_inset CommandInset label
LatexCommand label
name "fig:High-degree-polynomial-evaulatio"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename performance_5_0_low.png
	width 50col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Low-degree polynomial evaulation
\begin_inset CommandInset label
LatexCommand label
name "fig:Low-degree-polynomial-evaulation"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Parallel Matrix Ploynomial Benchmark
\begin_inset CommandInset label
LatexCommand label
name "fig:Parallel-Matrix-Ploynomial"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Calculation time (seconds) by the size of the input matrix (elements).
 All displayed timings are normalized by the input matrix degree.
\end_layout

\end_inset

Figure 
\begin_inset CommandInset ref
LatexCommand eqref
reference "fig:Parallel-Matrix-Ploynomial"

\end_inset

 shows the following findings:
\end_layout

\begin_layout Enumerate
As shown in figure 
\begin_inset CommandInset ref
LatexCommand eqref
reference "fig:High-degree-polynomial-evaulatio"

\end_inset

, high-degree polynomial evaluation exploits the benefits of parallel computatio
n - thus takes less time to evaluate than the naive Matlab implementation.
\end_layout

\begin_layout Enumerate
For low-degree polynomial calculations, Matlab's naive implementation takes
 less computation time even than the Schur decomposition itself
\end_layout

\begin_layout Enumerate
As shown in figures 
\begin_inset CommandInset ref
LatexCommand eqref
reference "fig:High-degree-polynomial-evaulatio"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand eqref
reference "fig:Low-degree-polynomial-evaulation"

\end_inset

, more than half of the parallel algorithm execution time is spent on the
 Schur decomposition calculation.
\end_layout

\begin_layout Enumerate
Other significant calculation-time steps are the eigenvalues reordering
 (yellow-colored) and Parlett Recurrence calculation (red-orange-colored).
\end_layout

\begin_layout Enumerate
For high-degree polynomials (figure 
\begin_inset CommandInset ref
LatexCommand eqref
reference "fig:High-degree-polynomial-evaulatio"

\end_inset

), the polynomial calculation takes approximately the same computation time
 as the Parlett Recurrence.
\end_layout

\begin_layout Subsection
Large vs.
 Small Diagonal Clusters
\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand eqref
reference "fig:Block-size-effect-on"

\end_inset

 shows the differences between splitting the input matrix into small blocks
 and large blocks.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename performance_5_1_large.png
	width 50col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Large blocks
\begin_inset CommandInset label
LatexCommand label
name "fig:block-size-Large-blocks"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename performance_5_1_small.png
	width 50col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Small blocks
\begin_inset CommandInset label
LatexCommand label
name "fig:block-size-Small-blocks"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename performance_5_1.png
	width 50col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Execution time comparison
\begin_inset CommandInset label
LatexCommand label
name "fig:block-size-Execution-time-comparison"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Block-size effect on execution time
\begin_inset CommandInset label
LatexCommand label
name "fig:Block-size-effect-on"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset

The following findings can be deducted:
\end_layout

\begin_layout Enumerate
As seen in figure 
\begin_inset CommandInset ref
LatexCommand eqref
reference "fig:block-size-Execution-time-comparison"

\end_inset

, small blocks exploit better parallelism, resulting lower execution times.
\end_layout

\begin_layout Enumerate
As seen in figures 
\begin_inset CommandInset ref
LatexCommand eqref
reference "fig:block-size-Large-blocks"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand eqref
reference "fig:block-size-Small-blocks"

\end_inset

:
\end_layout

\begin_deeper
\begin_layout Enumerate
Polynomial calculation time is significantly higher in the large blocks
 case (figure 
\begin_inset CommandInset ref
LatexCommand eqref
reference "fig:block-size-Large-blocks"

\end_inset

) than the small blocks (figure 
\begin_inset CommandInset ref
LatexCommand eqref
reference "fig:block-size-Small-blocks"

\end_inset

), supporting the claim that the overall polynomial calculation can be evaluated
 by applying Parlett Recurrence calculation on smaller blocks.
\end_layout

\begin_layout Enumerate
Schur decomposition is not affected by the blocks clustering
\end_layout

\begin_layout Enumerate
Smaller blocks (figure 
\begin_inset CommandInset ref
LatexCommand eqref
reference "fig:block-size-Small-blocks"

\end_inset

) result longer blocks reordering than the large blocks (figure 
\begin_inset CommandInset ref
LatexCommand eqref
reference "fig:block-size-Large-blocks"

\end_inset

)
\end_layout

\end_deeper
\begin_layout Subsection
Parlett vs.
 Sequential vs.
 Superdiagonal
\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand eqref
reference "fig:Parlett-Recurrence-calculation"

\end_inset

 shows the differences between Parlett Recurrence calculation techniques.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename performance_5_2_parallel.png
	width 50col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Parallel version for superdiagonal calculation (algorithm 
\begin_inset CommandInset ref
LatexCommand vref
reference "alg:Superdiagonal-Block-Parlett"

\end_inset

)
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename performance_5_2_parlett.png
	width 50col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Non-parallel version for superdiagonal calculation
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename performance_5_2_seq.png
	width 50col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Sequential calculation (algorithm 
\begin_inset CommandInset ref
LatexCommand vref
reference "alg:Sequential-iterations"

\end_inset

)
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename performance_5_2.png
	width 50col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Execution time comparison
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Parlett Recurrence calculation
\begin_inset CommandInset label
LatexCommand label
name "fig:Parlett-Recurrence-calculation"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Sylvester Solver Types
\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand eqref
reference "fig:Sylvester-solver-types"

\end_inset

 shows the differences between sylvester equation solver implementations.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename performance_5_3_lapack.png
	width 50col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
LAPACK implementation
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename performance_5_3_intel.png
	width 50col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Native Intel MKL implementation
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename performance_5_3_recursive.png
	width 50col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Recursive implementation (algorithm 
\begin_inset CommandInset ref
LatexCommand vref
reference "alg:Blocked-recursive-Sylvester"

\end_inset

)
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename performance_5_3.png
	width 50col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Execution time comparison
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Sylvester solver types
\begin_inset CommandInset label
LatexCommand label
name "fig:Sylvester-solver-types"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Number of cores
\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand eqref
reference "fig:Computation-cores-comparison"

\end_inset

 shows the differences between executing the parallel polynomial calculation
 algorithm on various processing cores.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename performance_5_4_1.png
	width 33col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
1 core
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename performance_5_4_2.png
	width 33col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
2 cores
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename performance_5_4_4.png
	width 33col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
4 cores
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename performance_5_4_8.png
	width 33col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Execution time comparison
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename performance_5_4.png
	width 66col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Execution time comparison
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Computation cores comparison
\begin_inset CommandInset label
LatexCommand label
name "fig:Computation-cores-comparison"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Eigenvalues reordering - Bubble vs.
 Smart
\end_layout

\end_body
\end_document
